name: Deploy RemoteHive to VPC

on:
  push:
    branches: [main, production]
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      force_deploy:
        description: 'Force deployment (skip tests)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}/remotehive
  VPC_HOST: ${{ secrets.VPC_HOST }}
  VPC_USER: ${{ secrets.VPC_USER }}
  VPC_SSH_KEY: ${{ secrets.VPC_SSH_KEY }}

jobs:
  # =============================================================================
  # CODE QUALITY AND TESTING
  # =============================================================================
  code-quality:
    name: Code Quality Checks
    runs-on: ubuntu-latest
    if: ${{ !inputs.force_deploy }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install black isort flake8 bandit pytest
          pip install -r requirements.txt
          
      - name: Run Black (Code Formatting)
        run: black --check --diff .
        
      - name: Run isort (Import Sorting)
        run: isort --check-only --diff .
        
      - name: Run Flake8 (Linting)
        run: flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        
      - name: Run Bandit (Security)
        run: bandit -r . -f json -o bandit-report.json || true
        
      - name: Upload Bandit Report
        uses: actions/upload-artifact@v3
        with:
          name: bandit-report
          path: bandit-report.json

  backend-tests:
    name: Backend API Tests
    runs-on: ubuntu-latest
    if: ${{ !inputs.force_deploy }}
    
    services:
      mongodb:
        image: mongo:7.0
        env:
          MONGO_INITDB_ROOT_USERNAME: admin
          MONGO_INITDB_ROOT_PASSWORD: testpass
          MONGO_INITDB_DATABASE: remotehive_test
        ports:
          - 27017:27017
          
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
          
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-asyncio pytest-cov
          
      - name: Wait for MongoDB
        run: |
          until mongosh --host localhost:27017 --username admin --password testpass --eval "db.adminCommand('ping')" > /dev/null 2>&1; do
            echo "Waiting for MongoDB..."
            sleep 2
          done
          
      - name: Run Backend Tests
        env:
          MONGODB_URL: mongodb://admin:testpass@localhost:27017/remotehive_test?authSource=admin
          REDIS_URL: redis://localhost:6379/0
          JWT_SECRET_KEY: test-secret-key-for-ci
          ENVIRONMENT: test
        run: |
          pytest app/tests/ -v --cov=app --cov-report=xml
          
      - name: Upload Coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          flags: backend

  frontend-tests:
    name: Frontend Tests
    runs-on: ubuntu-latest
    if: ${{ !inputs.force_deploy }}
    
    strategy:
      matrix:
        app: [remotehive-admin, remotehive-public]
        
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: ${{ matrix.app }}/package-lock.json
          
      - name: Install dependencies
        working-directory: ${{ matrix.app }}
        run: npm ci
        
      - name: Run linting
        working-directory: ${{ matrix.app }}
        run: npm run lint
        
      - name: Run type checking
        working-directory: ${{ matrix.app }}
        run: npm run type-check || true
        
      - name: Run tests
        working-directory: ${{ matrix.app }}
        run: npm run test || true
        
      - name: Build application
        working-directory: ${{ matrix.app }}
        run: npm run build

  # =============================================================================
  # DOCKER IMAGE BUILDING
  # =============================================================================
  build-images:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [code-quality, backend-tests, frontend-tests]
    if: always() && (needs.code-quality.result == 'success' || needs.code-quality.result == 'skipped') && (needs.backend-tests.result == 'success' || needs.backend-tests.result == 'skipped') && (needs.frontend-tests.result == 'success' || needs.frontend-tests.result == 'skipped')
    
    strategy:
      matrix:
        service:
          - name: backend-api
            context: .
            dockerfile: Dockerfile
          - name: autoscraper-service
            context: autoscraper-service
            dockerfile: autoscraper-service/Dockerfile
          - name: admin-panel
            context: remotehive-admin
            dockerfile: remotehive-admin/Dockerfile
          - name: public-website
            context: remotehive-public
            dockerfile: remotehive-public/Dockerfile
            
    outputs:
      backend-api-tag: ${{ steps.meta-backend-api.outputs.tags }}
      autoscraper-service-tag: ${{ steps.meta-autoscraper-service.outputs.tags }}
      admin-panel-tag: ${{ steps.meta-admin-panel.outputs.tags }}
      public-website-tag: ${{ steps.meta-public-website.outputs.tags }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Extract metadata
        id: meta-${{ matrix.service.name }}
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${{ matrix.service.name }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.context }}
          file: ${{ matrix.service.dockerfile }}
          push: true
          tags: ${{ steps.meta-${{ matrix.service.name }}.outputs.tags }}
          labels: ${{ steps.meta-${{ matrix.service.name }}.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

  # =============================================================================
  # VPC DEPLOYMENT
  # =============================================================================
  deploy-to-vpc:
    name: Deploy to VPC
    runs-on: ubuntu-latest
    needs: [build-images]
    environment: ${{ inputs.environment || 'production' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPC_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.VPC_HOST }} >> ~/.ssh/known_hosts
          
      - name: Copy deployment files to VPC
        run: |
          scp -r k8s/ docker-compose.yml .env.example ${{ env.VPC_USER }}@${{ env.VPC_HOST }}:~/remotehive-deployment/
          
      - name: Deploy to VPC
        run: |
          ssh ${{ env.VPC_USER }}@${{ env.VPC_HOST }} << 'EOF'
            cd ~/remotehive-deployment
            
            # Update environment variables
            if [ ! -f .env ]; then
              cp .env.example .env
              echo "Please update .env file with production values"
            fi
            
            # Pull latest images
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-backend-api:latest
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-autoscraper-service:latest
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-admin-panel:latest
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-public-website:latest
            
            # Deploy with Docker Compose
            docker-compose down --remove-orphans
            docker-compose up -d
            
            # Wait for services to be healthy
            echo "Waiting for services to start..."
            sleep 30
            
            # Check service health
            docker-compose ps
            
            # Run database migrations if needed
            docker-compose exec -T backend-api python -m alembic upgrade head || true
            
            # Clean up old images
            docker image prune -f
          EOF
          
      - name: Verify Deployment
        run: |
          ssh ${{ env.VPC_USER }}@${{ env.VPC_HOST }} << 'EOF'
            cd ~/remotehive-deployment
            
            # Check if all services are running
            if docker-compose ps | grep -q "Up"; then
              echo "✅ Services are running"
              docker-compose ps
            else
              echo "❌ Some services failed to start"
              docker-compose logs --tail=50
              exit 1
            fi
            
            # Test API endpoints
            echo "Testing API endpoints..."
            
            # Test backend API health
            if curl -f http://localhost:8000/health > /dev/null 2>&1; then
              echo "✅ Backend API is healthy"
            else
              echo "❌ Backend API health check failed"
            fi
            
            # Test autoscraper service health
            if curl -f http://localhost:8001/health > /dev/null 2>&1; then
              echo "✅ Autoscraper service is healthy"
            else
              echo "❌ Autoscraper service health check failed"
            fi
            
            # Test admin panel
            if curl -f http://localhost:3000 > /dev/null 2>&1; then
              echo "✅ Admin panel is accessible"
            else
              echo "❌ Admin panel is not accessible"
            fi
            
            # Test public website
            if curl -f http://localhost:5173 > /dev/null 2>&1; then
              echo "✅ Public website is accessible"
            else
              echo "❌ Public website is not accessible"
            fi
          EOF

  # =============================================================================
  # KUBERNETES DEPLOYMENT (Optional)
  # =============================================================================
  deploy-to-kubernetes:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [build-images]
    if: ${{ github.event.inputs.environment == 'production' && contains(github.ref, 'refs/tags/') }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPC_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.VPC_HOST }} >> ~/.ssh/known_hosts
          
      - name: Deploy to Kubernetes
        run: |
          ssh ${{ env.VPC_USER }}@${{ env.VPC_HOST }} << 'EOF'
            cd ~/remotehive-deployment
            
            # Check if kubectl is available
            if ! command -v kubectl &> /dev/null; then
              echo "kubectl not found, installing..."
              curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
              chmod +x kubectl
              sudo mv kubectl /usr/local/bin/
            fi
            
            # Apply Kubernetes manifests
            kubectl apply -f k8s/namespace.yaml
            kubectl apply -f k8s/persistent-volumes.yaml
            kubectl apply -f k8s/mongodb.yaml
            kubectl apply -f k8s/redis.yaml
            kubectl apply -f k8s/backend-api.yaml
            kubectl apply -f k8s/autoscraper-service.yaml
            kubectl apply -f k8s/admin-panel.yaml
            kubectl apply -f k8s/public-website.yaml
            kubectl apply -f k8s/celery-workers.yaml
            kubectl apply -f k8s/ingress.yaml
            
            # Wait for deployment to complete
            kubectl rollout status deployment/backend-api -n remotehive --timeout=300s
            kubectl rollout status deployment/autoscraper-service -n remotehive --timeout=300s
            kubectl rollout status deployment/admin-panel -n remotehive --timeout=300s
            kubectl rollout status deployment/public-website -n remotehive --timeout=300s
            
            # Show deployment status
            kubectl get pods -n remotehive
            kubectl get services -n remotehive
          EOF

  # =============================================================================
  # NOTIFICATION
  # =============================================================================
  notify:
    name: Send Deployment Notification
    runs-on: ubuntu-latest
    needs: [deploy-to-vpc]
    if: always()
    
    steps:
      - name: Send Success Notification
        if: needs.deploy-to-vpc.result == 'success'
        run: |
          echo "🚀 RemoteHive deployment successful!"
          echo "Environment: ${{ inputs.environment || 'production' }}"
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref_name }}"
          
      - name: Send Failure Notification
        if: needs.deploy-to-vpc.result == 'failure'
        run: |
          echo "❌ RemoteHive deployment failed!"
          echo "Environment: ${{ inputs.environment || 'production' }}"
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Please check the logs for more details."